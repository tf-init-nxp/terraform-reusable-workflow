name: 'Terraform Pull Request Task'

on:
  workflow_call:
    inputs:
      terraform_version:
        description: 'Terraform Version to be used'
        required: true
        type: string
    #   destroy:
    #     description: 'True to destroy all the infraestructure'
    #     required: false
    #     type: boolean
env:
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  

jobs:
  terraform-pull-request:
    name: 'Terraform Pull Request'
    runs-on: ubuntu-latest
    env:
      #this is needed since we are running terraform with read-only permissions
      ARM_SKIP_PROVIDER_REGISTRATION: true
#    defaults:
#      run:
#        working-directory: ${{ env.tf_actions_working_dir }}
#    permissions:
#      pull-requests: write
    steps:
    - uses: actions/checkout@v3
    - uses: hashicorp/setup-terraform@v2
      with:
        terraform_wrapper: false

    # - name: Terraform fmt
    #   id: fmt
    #   run: terraform fmt -check
    #   continue-on-error: true
    - name: Getting Branch
      id: getting_branch
      run: |
        echo "BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> "$GITHUB_ENV"
        
        
    - name: Preparing Variables
      id: prepvars
      run: |
        echo "TF_KEY_STATE=${GITHUB_REPOSITORY#*/}" >> "$GITHUB_ENV"
        if [ "${{ env.BRANCH_NAME }}" = "main" ]; then
            echo "working on Prod"
            echo "ARM_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID_PROD }}" >> $GITHUB_ENV
            echo "TF_STATE_SA=${{ vars.TF_STATE_SA_PROD }}" >> $GITHUB_ENV
            echo "TF_CONTAINER_NAME=${{ vars.TF_CONTAINER_NAME_PROD }}" >> $GITHUB_ENV
            echo "TF_RG_NAME=${{ vars.TF_STATE_RG_PROD }}" >> $GITHUB_ENV
        else
            echo "working on Dev"
            echo "ARM_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID_DEV }}" >> $GITHUB_ENV
            echo "TF_STATE_SA=${{ vars.TF_STATE_SA_DEV }}" >> $GITHUB_ENV
            echo "TF_CONTAINER_NAME=${{ vars.TF_CONTAINER_NAME_DEV }}" >> "$GITHUB_ENV"
            echo "TF_RG_NAME=${{ vars.TF_STATE_RG_DEV }}" >> $GITHUB_ENV
        fi
      shell: bash
      
    - uses: Azure/login@v1
      with:
        creds: '{"clientId":"${{ vars.TEMP_CLIENT_ID }}","clientSecret":"${{ vars.TEMP_SECRET }}","subscriptionId":"${{ vars.TEMP_SUBS_ID }}","tenantId":"${{ vars.TEMP_TENANT_ID }}"}'

    - name: Terraform Init
      id: init
      #run: terraform init
      # terraform init -backend-config=storage_account_name=tfstatefile01 -backend-config=container_name=tfstate -backend-config=key=dev-network.terraform.tstate -backend-config=resource_group_name=DefaultResourceGroup-EUS -backend-config=subscription_id=2a04288a-8136-4880-b526-c6070e59f004 -backend-config=tenant_id=37d20c78-05e3-416d-83ab-cdbc21fed22a -backend-config=client_id=*** -backend-config=client_secret=***
      run: |
        terraform init -backend-config=storage_account_name=${{ env.TF_STATE_SA }} \
          -backend-config=container_name=${{ env.TF_CONTAINER_NAME }} \
          -backend-config=resource_group_name=${{ env.TF_RG_NAME }} \
          -backend-config=key="${{ env.TF_KEY_STATE }}" \
          -backend-config=subscription_id=${{ vars.TEMP_SUBS_ID }} \
          -backend-config=tenant_id=${{ vars.TEMP_TENANT_ID }} \
          -backend-config=client_id=${{ vars.TEMP_CLIENT_ID }} \
          -backend-config=client_secret=${{ secrets.TEMP_SECRET }}
  
    # - name: Terraform Validate
    #   id: validate
    #   run: terraform validate -no-color

    #- name: Terraform Plan
    #  id: plan
    #  run: terraform plan -no-color
    #  continue-on-error: true
    
    - name: Terraform Plan
      id: tf-plan
      run: |
        export exitcode=0
     #   terraform plan -detailed-exitcode -no-color -out tfplan || export exitcode=$?

      #  echo "exitcode=$exitcode" >> $GITHUB_OUTPUT
        
      #  if [ $exitcode -eq 1 ]; then
      #    echo Terraform Plan Failed!
      #    exit 1
      #  else 
      #    exit 0
      #  fi

    #- uses: actions/github-script@v6
    #  if: github.event_name == 'pull_request'
    #  env:
    #    PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
    #  with:
    #    github-token: ${{ secrets.GITHUB_TOKEN }}
    #    script: |
    #      // 1. Retrieve existing bot comments for the PR
    #      const { data: comments } = await github.rest.issues.listComments({
    #        owner: context.repo.owner,
    #        repo: context.repo.repo,
    #        issue_number: context.issue.number,
    #      })
    #      const botComment = comments.find(comment => {
    #        return comment.user.type === 'Bot' && comment.body.includes('Terraform Format and Style')
    #      })
    #
    #      // 2. Prepare format of the comment
    #      const output = `#### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
    #      #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
    #      #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
    #      <details><summary>Validation Output</summary>
    #
    #      \`\`\`\n
    #      ${{ steps.validate.outputs.stdout }}
    #      \`\`\`
    #
    #      </details>
    #
    #      #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`
    #
    #      <details><summary>Show Plan</summary>
    #
    #      \`\`\`\n
    #      ${process.env.PLAN}
    #      \`\`\`
    #
    #      </details>
    #
    #      *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`${{ env.tf_actions_working_dir }}\`, Workflow: \`${{ github.workflow }}\`*`;
    #
    #      // 3. If we have a comment, update it, otherwise create a new one
    #      if (botComment) {
    #        github.rest.issues.updateComment({
    #          owner: context.repo.owner,
    #          repo: context.repo.repo,
    #          comment_id: botComment.id,
    #          body: output
    #        })
    #      } else {
    #        github.rest.issues.createComment({
    #          issue_number: context.issue.number,
    #          owner: context.repo.owner,
    #          repo: context.repo.repo,
    #          body: output
    #        })
    #      }
